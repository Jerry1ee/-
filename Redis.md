# Redis

### 缓存雪崩

​	大量缓存设置过期时间相同，导致某一时间点用户查询都无法从缓存中直接得到数据，进而都去查询数据库，造成数据库压力过大

- 解决：对数据库访问进行限制，采用加锁或队列方式限制某一时间点的并发访问，或者将缓存失效时间进行分散处理

### 缓存穿透

​	用户查询数据，在缓存中没有，在数据库中也没有，但用户不知道，依然进行了两次重复性的查询操作，造成浪费资源，缓存命中率降低

- 解决：采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitMap中，一个一定不存在的数据会被这个bitmap拦截，避免查询数据库
- 或者查询数据库为空的时候依然将空结果进行缓存，

### 缓存击穿

​	用户查询数据，缓存中没有，但数据库中有，一般是因为缓存过期了。。。并发数多，同时去数据库取数据，造成数据库压力瞬间增大

- 设置热点数据永不过期
- 加互斥锁



### **并发下数据缓存不一致问题分析**

问题：
　　第一个请求数据发生变更，先删除了缓存，然后要去修改数据库，此时还没来得及去修改；
　　第二个请求过来去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中；
　　第三个请求读取缓存中的数据 (此时第一个请求已经完成了数据库修改的操作)。
　　完了，数据库和缓存中的数据不一样了。。。。



解决：

- 将数据库缓存更新和读取操作进行串行化
- 项目里维护一组线程池和内存队列
- 更新数据时，根据数据唯一标志将请求路由到一个jvm队列中，然后更新，请求结束
- 读数据时，先查缓存，数据不存在，根据唯一标志路由，发送到同一jvm队列中，重新读取后更新缓存
- 由于都在同一队列中，执行顺序具有先后性

上面的场景变成：

​	第一个请求数据发生变更，删除缓存，修改数据库，此时还没来得及去修改，这个请求路由到了一个队列A中

​	第二个请求过来读缓存，发现缓存空了，去查询数据库，此时也把这个请求路由到队列A中

​	这个时候就必须等第一个请求更新完之后，才能执行第二个请求，就不会造成不一致了

### 常见应用场景

```text
缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；

排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；

计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；

好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；

简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；

Session共享，以PHP为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问
```

