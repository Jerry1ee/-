# JVM相关知识

## 1.Java虚拟机

### 准确式内存管理

​	一款名为Exact VM的虚拟机，采用准确是内存管理，指虚拟机可以知道内存中某个位置的数据具体是什么类型。

​	如内存中有一个32bit的整数123456，虚拟机有能力分辨出它是**指向一个123456的内存地址的引用类型**还是**一个数值为123456的整数**

## 2.Java内存区域与内存溢出异常

### Java内存区域（运行时数据区域）和内存模型（JMM）

- 内存区域：JVM运行时将数据分区域存储，强调对内存空间的划分
- 内存模型：线程和主内存之间的抽象关系，JVM在计算机内存中的工作方式

### Java运行时数据区域

- ##### JDK8之后的JVM内存布局

![image-20200206132931885](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200206132931885.png)

- ##### 程序计数器（Program Counter Register）

  - 一块较小内存空间，可看作当前线程所执行的**字节码行号指示器**
  - **多线程**实际上是通过线程轮流切换并分配处理器执行时间的方式来实现，即任一确定时间，一个处理器内核都只会执行一条线程中的指令，只不过切换得很快，不易察觉
  - **线程私有**：切换后能恢复到正确执行位置，每个线程都要有一个独立额程序计数器
  - 若正在执行Native方法，则计数器数值为空

- ##### Java虚拟机栈

  - **线程私有**
  - 描述Java方法执行的内存模型：每个方法在执行的同时都会创建一个**栈帧**用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**一个方法对应一个栈帧**
  - 活动线程中，只有栈顶的帧才有效，称为**当前栈帧**
  - ![image-20200206134233800](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200206134233800.png)
  - 1、局部变量表（内存）
    - 存放方法参数和局部变量，必须显式初始化
    - 若是非静态方法，在index[0]位置上**存储方法所属对象的实例引用（占4字节）**，随后存储参数和局部变量
    - 字节码中STORE指令：将操作栈中计算完成的布局变量写回局部变量表
    - 两种异常：
      - StackOverflowError：线程请求栈深度大于虚拟机允许的深度
      - OutOfMemoryError：若虚拟机可动态扩展，扩展时无法申请到足够内存
  - 2、操作栈（寄存器）
    - 初始状态为空的桶式结构栈；JVM执行引擎基于的栈
    - **栈的深度**：方法元信息的stack属性中
    - i++和++i的区别：
      - i++：从局部变量表取出i并压入操作栈；对局部变量表中i自增1；将操作栈栈顶值取出使用；使用栈顶值更新局部变量表
      - ++i：先对局部变量表的i自增1；取出并压入操作栈；将操作栈栈顶值取出使用；使用栈顶值更新局部变量表
    - **i++不是原子操作！**用volatile修饰也不安全，分3步完成，可能会被其他线程打断
  - 3、动态链接
    - 每个栈帧中包含一个在常量池中对当前方法的引用
  - 4、方法返回地址
    - **正常退出**和**异常退出**
    - 方法退出相当于弹出当前栈帧，三种方式：
      - 返回值压入上层调用栈帧
      - 异常处理信息抛给能处理的栈帧
      - PC计数器指向方法调用后的下一条指令

- ##### 本地方法栈

  - **线程私有**
  - 与Java虚拟机栈类似，它为Native方法服务（HotSpot将其合二为一）
  - 本地方法可通过JNI（Java Native Interface）访问虚拟机运行时数据区，调用寄存器
  - 本地方法栈内存不足时，抛出NativeHeapOutOfMemory异常

- ##### Java堆

  - Java堆一般来说是虚拟机管理最大的一块内存，**线程共享**，虚拟机启动时创建
  - 唯一目的：**存放对象实例**
  - 别名：**GC堆**
  - 细分方法：
    - 内存回收角度：新生代、老年代；Eden空间，From Survivor和To Survivor空间
    - 内存分配角度：划分出多个**线程私有的分配缓冲区（Thread Local Allocation Buffer）**,即TLAB
  - 逻辑连续，物理可不连续；一般可扩展（通过参数-Xmx和-Xms控制）

- ##### 方法区

  - **线程共享**，存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码等数据**
  - 可以不实现垃圾收集，内存回收目标：**常量池回收**以及**类型卸载**
  - 方法区无法满足内存分配需求，抛出OutOfMemoryError异常
  - 为什么使用元空间取代永久代？
    - 字符串存在永久代中，容易出现性能问题和内存溢出
    - 类及方法信息难定大小，永久代大小指定不好控制
    - 永久代为GC带来复杂度，降低回收效率
    - 将HotSpot和JRockit合并
  - 1、运行时常量池
    - Class文件中除了类的版本、字段、方法、接口等描述信息，还有**常量池**
    - 用于存放编译期生成的**各种字面量**和**符号引用**
    - **动态性：**不同于Class文件常量池，运行期间可以将新常量放入池（String类的intern()方法）
  - 2、直接内存
    - JDK1.4引入NIO，一种基于**Channel和Buffer的I/O方式**，可以使用Native函数库直接分配堆外内存，通过一个存储在Java堆中的**DirectByteBuffer对象**作为这块内存的引用进行操作，避免了Java堆和Native堆中来回复制数据
    - 

### Java内存模型

- **共享内存的并发模型**，线程间通过**读-写共享变量**（堆内存中的实例域，静态域和数组元素）来完成隐式通信

- ##### 计算机高速缓存和缓存一致性

  - CPU（高速）——缓存——内存（低速），有可能有多个处理器（核），会导致缓存不一致，处理器访问回缓存时需要遵循一些协议

- ##### JVM主内存与工作内存

  - 线程A先把本地内存A更新的共享变量刷新到主内存中
  - 线程B到主内存中读线程A之前已更新过的共享变量
  - 这样线程AB就完成了通信

### volatile关键字

- ##### JVM提供的最轻量级的同步机制，当变量定义为volatile后，它将具备两种特性：

  - **保证此变量对所有线程的可见性**：普通变量在线程中传递时均需要通过主内存来完成
    - 注意：虽然volatile保证可见行，但Java里的运算并非原子操作，并发下的volatile变量依然不安全；而synchronized关键字则是“一个变量在同一时刻只允许一条线程对其进行lock操作”
  - **禁止指令重排序优化**：普通变量无法保证变量赋值操作与程序代码中执行顺序一致，会出现读取的值其实已经被改变了，却还是读取原来的值

### HotSpot虚拟机堆中的对象

- ##### 对象的创建（new 指令）

  - **1）类加载检查：**检查该指令参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。若没有，先把该类加载进内存；
  - **2）分配内存：**类加载检查通过后，虚拟机将为对象分配内存，此时可以确定存储该对象所需要的内存大小
  - **如何在堆中为其分配内存？**
    - 指针碰撞（内存规整）
      - 由一个指针分隔用过的和没用的内存，分局两侧
      - 将指针向没用的内存方向移动所需要的长度即可
    - 空闲列表（内存不规整）
      - 维护一个列表，记录哪些内存块可用
      - 从列表中选一个足够大的内存分配给对象，并更新列表
  - **3）内存初始化**
  - **4）设置对象头中的数据**
  - **5）Java程序开始创建对象：**此时虚拟机认为对象已经创建好了，但Java程序还没开始执行构造函数

- ##### 如何处理多线程创建对象时，划分内存的指针同步问题？

  - 对分配内存空间的动作进行同步处理（CAS）
  - 把内存分配动作按照线程划分在不同的空间中进行
    - 每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）
    - 哪个线程要分配内存就在哪个线程的TLAB上分配，**TLAB用完需要分配新的TLAB时，才需要同步锁定**
    - 通过 `-XX:+/-UseTLAB` 参数设定是否使用 TLAB。

- ##### 对象的内存布局

  - 对象头：
    - 第一部分：存储对象自身运行时的数据，HashCode、GC分代年龄。。。
    - 第二部分：类型指针，指向它的类的元数据，虚拟机通过这个指针判断该对象是哪个类的实例（HotSpot采用的是直接指针）
    - 数组对象对象头中由一块记录数据长度
  - 实例数据：
    - 默认分配顺序：longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，同宽分配在一起，长度由长到短（oops除外）
    - 默认分配顺序下，父类字段分配在子类字段前面
  - 对齐填充（*HotSpot VM要求对象的起始地址必须是8字节的整数倍，所以不够要补齐*）

- ##### 对象的访问

  - Java需要通过**虚拟机栈上的reference**来操作**堆上的具体对象**，reference数据指向对象的引用，这个引用定位到具体对象主要有两种方式：
  - 句柄访问
    - 在Java堆中划分一块内存作为句柄池，每个句柄存放到对象实例数据和对象类型数据的指针
    - 优点：对象移动时，仅需要更新句柄池中对象实例数据指针，reference较稳定
    - ![image-20200206160805034](C:\Users\lzy\AppData\Roaming\Typora\typora-user-images\image-20200206160805034.png)
  - 直接指针访问
    - 在Java堆对象的实例数据中存放一个指向对象类型数据的指针，HotSpot在对象头中存放一个指向对象类型数据指针
    - 优点：减少一次指针访问，速度块

### OOM异常

- ##### Java堆溢出

  - 出现标志：`java.lang.OutOfMemoryError: Java heap space`
  - 解决方法：
    - 内存映像分析工具，分析Dump出来的堆转储快照，确定是内存泄漏还是内存溢出
    - 内存泄漏：泄漏对象到GC Root引用链，定位泄漏位置
    - 不存在内存泄漏，查看虚拟机大小是否可以增加，哪些对象生命周期过长
  - 虚拟机参数：-XX:HeapDumpOnOutOfMemoryError

- ##### Java虚拟机栈和本地方法栈溢出

  - 单线程下，栈帧过大、虚拟机容量过小导致StackOverFlowError
  - 如果因为多线程导致的OutOfMemoryError，在不能减少线程数或更换64位虚拟机的情况下，只能通过减少最大堆和减少栈容量来换取更多线程
  - Java堆出现OOM要调大堆内存，栈出现OOM则要考虑调小栈容量

- ##### 方法区和运行时常量池溢出

  - 经常动态生成大量类的应用中（Spring框架，使用CGLib字节码技术），方法区溢出比较常见

- ##### 直接内存溢出

  - Heap Dump 文件中看不见明显异常，程序中直接或间接用了 NIO；

## 3.垃圾收集器与内存分配策略

主要发生在Java堆和方法区中

### 判断对象生死

- ##### 引用计数算法

  - 给对象添加一个引用计数器
  - 每被引用一次，计数器加一
  - 引用失效时，计数器减一
  - 计数器为0时对象不再可用
  - **缺点：**难以解决循环引用问题

- ##### 可达性分析算法（主流）

  - 从GC Root对象作为起点开始向下搜索，走过的路径称为引用链

  - 从GC Root开始，不可达的对象被判为不可用

  - 可作为GC Root的对象：

    - 栈中：	

      - 虚拟机栈中，栈帧中的本地变量表引用的对象
      - 本地方法栈中，JNI引用的对象

    - 方法区中：

      - 类的静态属性引用的对象
      - 常量引用的对象

    - 可总结为：

      1，所有年老带对象
      2，所有全局对象
      3，所有jni句柄
      4，所有上锁对象
      5，jvmti持有的对象
      6，代码段code_cache
      7，所有classloader，及其加载的class
      8，所有字典
      9，flat_profiler和management
      10，最重要的，所有运行中线程栈上的引用类型变量

      作者：cao
      链接：https://www.zhihu.com/question/33093157/answer/89516243
      来源：知乎
      著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

  - 对象在判为不可达后，仍有自救方法

- ##### 四种引用类型

  - 强引用：Object obj = new Object()；强引用还在，GC永远不会回收被引用独享
  - 软引用：引用存在但不是必须的对象，在OOM前，虚拟机将这些对象列入回收范围进行第二次回收，若内存依然不够，再抛出OOM
  - 弱引用：只能生存到下一次GC前，一旦发生垃圾收集，就会被清理
  - 虚引用：不影响对象，无法获取对象实例，唯一用途：回收时让系统知道

- ##### 宣告对象死亡的两次标记过程

  - 发现对象不可达，第一次标记，判断是否执行finalize（）
    - 不需要执行：对象没有覆盖finalize方法或finalize方法已经执行过（finalize方法只被执行一次）
    - 需要执行：将该对象放入 F-Queue,稍后由虚拟机自动创建一个低优先级线程执行
  - finalize（）无法像C，C++析构函数那样，虚拟机不等待它执行结束

- ##### 方法区的回收

  - 主要回收 **废弃常量 **和 **无用的类**
    - 废弃常量：字符串“abc”，没有引用指向它，它就是废弃常量
    - 无用的类：
      - 该类所有实例以已被回收
      - 加载该类的Classloader已被回收
      - 该类的Class对象没有被任何地方引用，反射无法访问该类的方法

### 垃圾收集算法

- ##### 标记-清除算法

  - 标记所有需要回收的对象
  - 标记完毕，统一回收所有被标记对象
  - 缺点：
    - 标记和清理过程效率低下（很多需要被清理）
    - 空间碎片问题：导致下一次找不到大块内存，提前触发GC

- ##### 标记-复制算法

  - 将可用内存分为两块，每次只用一块
  - 一块内存用完时，将这块内存中还存活的对象复制到另一块内存上，清除这块内存
  - 缺点：
    - 内存缩小为一半，浪费空间，仅适合新生代
  - 节省内存的方法：
    - 分为1块较大的Eden区，2块较小的Survivor区
    - 每次使用1块Eden区和1块Survivor区
    - 回收时，将上面两部分存活的对象复制到另一块Survivor区中，然后清除
    - 原因：假说1 新生代中对象98%都是朝生夕死的

- ##### 标记-整理算法

  - 标记方法同 标记-清除算法
  - 标记完后，将所有存货对象向一端移动，然后直接清理边界外的内存
  - 缺点：
    - 存在效率问题（移动耗费较大），只适合老年代

- ##### 进化：分代收集算法

  - 新生代：GC过后只存活少量对象 **复制算法**
  - 老年代：GC过后对象存活率搞 **标记**-**整理算法**

### HotSpot中GC算法的实现

##### GC算法的步骤：找到死掉的对象；清理

![GC的算法实现.png](https://github.com/TangBean/understanding-the-jvm/raw/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/pic/GC%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.png)

- ##### 枚举GC Root（可达性分析的第一步）

  - 因：每次枚举如果都要遍历栈，时间成本太大
  - 果：使用OopMap数据结构，**记录栈上本地变量到堆上对象的引用关系**
  - 因：Oop需要更新，但执行一条指令就改一次，成本太高
  - 果：采用在 **安全点**更新的方法，安全点需要将程序运行时间划分合理，一般在
    - **方法调用、循环跳转、异常跳转**这些长时间执行的指令复用行为中设置安全点
  - 因：为保证枚举根节点的准确性
  - 果：需要Stop the world(GC停顿)，冻结整个应用

- **如何让所有线程跑到最近的安全点再停顿下来以便进行GC？**

  - 抢先式中断：
    - 先中断所有线程
    - 发现有线程没中断在安全点，恢复他让它跑到安全点
  - **主动式中断（主要使用）**：
    - 设置一个中断标记
    - 每个线程到达安全点时，检查此标记，选择是否中断自己

- **安全区域**

  - 指在一段代码片段中，引用关系不会发生变化，在这个区域中任意位置开始GC都是安全的
  - 因：一个Sleep或Blocked状态的线程无法自己到达安全点并中断自己，GC不能一直等待它
  - 果：线程执行到安全区域时，检查系统是否在GC，若不在GC，则继续执行；若在GC，等GC结束再继续执行

- ##### 7个垃圾收集器

  - Serial 搭配 Serial Old收集器：新生代-复制算法；老年代-标记整理算法
  - ParNew 搭配 Serial Old收集器：新生代-复制算法；老年代-标记整理算法(新生代收集改为多线程)
  - Parallel搭配Parallel Scavenge收集器：关注达到一个可控的吞吐量，都是多线程处理
    - 吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )
  - CMS收集器（Concurrent Mark Sweep）：
    - 并发低停顿
    - 1初始标记——2**并发**标记——3重新标记——4**并发**清理——5重置线程
      - 1标记GC Root直接关联的对象，为下一步并发标记做准备
      - 2进行GC Root 可达性分析
      - 3修正并发标记期间因用户线程继续运作导致产生的变动部分的标记记录
      - 4清除阶段
    - 缺点：
      - 1.对CPU资源敏感：并发执行会占用一部分CPU资源
      - 2.无法处理浮动垃圾：在CMS并发标记、清理阶段，用户线程产生的垃圾（并发要求为用户预留空间，有时候预留的空间会不足）
      - 标记-清除产生大量空间碎片
  - G1收集器
    - 
  - GC日志解读
  - ![GC日志解读.png](https://github.com/TangBean/understanding-the-jvm/raw/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/pic/GC%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB.png)
  - 

