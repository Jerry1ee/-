面试问题

1. 网络/数据库/Java 好好复习, Java 一定要看JDK源码关注并发和JVM,https://github.com/clsaa/road/tree/master/spring-recruitment 

   最近已经在读《深入理解Java虚拟机》，源码在准备在看

2. SpringBoot的优势是什么? 自动配置/依赖的原理是什么?

   - 优势
     - 相较于传统SSM框架中SpringMVC，自动配置更加方便，
     - 自动管理依赖
     - 自带应用监控，支持自定义配置日志文件，方便开发人员追踪错误
   - 自动配置
     - 通过注解@EnableAutoConfiguration，扫描ClassPath目录中自动配置类对应的依赖
     - 导入所有自动配置的类，加载spring.factories文件
     - 获取默认配置并初始化Bean
   - 起步依赖
     - 本质上是一个maven对象模型，定义了对其他库的传递依赖，所有依赖加在一起支持某项功能
     - Spring Boot将很多场景做成starter，需要哪些场景，直接引入starter即可

3. Netty线程模型? Netty为什么性能高? 什么是NIO/BIO/AIO? Netty源码看过哪些?Netty为什么要自己实现ThreadLocal?介绍一下Netty的整体架构? 介绍一下EventLoop和channel

   - Netty线程模型
     - 单线程模型：所有IO操作都由同一个NIO线程处理，接收客户端连接，将请求分发到对应事件处理handler中
     - 多线程模型：由一组NIO线程监听服务端，接收TCP连接请求，使用线程池处理大量IO操作，一个NIO线程可以处理多条链路，但每一条链路只对应线程池中的一个线程
     - 主从线程模型：一组线程池接收请求，另一组线程池处理IO
     - Netty的线程模型类似于多路复用的Reactor的主从线程模型：
       - 提供一个线程池接收请求，其中包含多个线程
       - 提供一个线程池处理请求，其中也包含多个线程
       - 每个Channel（接收的请求）都会被分配一个线程EventLoop，且处理的过程中也仅有此一个EventLoop线程
   - 性能高的原因（RPC性能三要素：IO模型，数据协议，线程模型）：
     - Netty是一个异步事件驱动的NIO框架，所有IO操作都是异步非阻塞的，可以应对高并发的场景
     - 零拷贝功能，接收和发送bytebuffer都直接用堆外内存进行socket读写，不需要进行二次拷贝到字节缓冲区；组合buffer对象可以同时操作多个小buffer对象；可以直接将文件缓冲区的数据发到目标Chanel，而不用循环write
     - 内存池可以将缓冲区重用，避免堆外内存的分配回收
   - NIO/BIO/AIO:
     - NIO（同步非阻塞IO）：
       - 有三个组成部分channel，buffer和selector
       - 采用多路复用器selector不断轮询注册在其上的channel（如数据传输，连接开启），然后从channel中读取数据到buffer中
       - NIO的数据操作都在buffer中进行
       - 单个线程可以负责多个数据通道，实现非阻塞
     - BIO（同步阻塞式IO）：
       - 一请求一应答模式，服务端采用acceptor线程监听客户端请求
       - 在IO过程完成前，线程会一直阻塞在那里，容易产生性能瓶颈
       - 频繁创建销毁线程开销大，并发处理能力差
     - AIO：异步非阻塞IO，不需要一直轮询channel，只用向系统注册IO监听，通过订阅-通知的方式实现异步性
   - 源码
     - EventLoopGroup
     - BootStrap
     - FastThreadLocal
   - 为什么自己实现ThreadLocal?
     - ThreadLocal解决场景：多个线程使用一个变量，但这个变量在不同线程中可以有不同的值，而非共享该变量的值，每个Thread维护一个ThreadLocalMap哈希表，key是ThreadLocalHashCode代表实例本身，value是要存储的值
     - JDK中的线程，都有一个ThreadLocalMap实例变量，每次进行元素操作时，都要通过哈希算法结合哈希表取值，而Netty自己实现的FastThreadLocal，在创建FastThreadLocalThread时就分配一个下标index给它，操作时直接用下标定位即可，效率更高（注意线程必须是FastThreadLocalThread或其子类）
   - 整体架构（业务流程架构？）
     - BootStrap 配置整个Netty程序，作为启动入口，串联组件
     - 当一个连接到达，Netty注册一个channel，EventLoopGroup分配一个EventLoop绑定该channel，整个channel的生命周期中都由这个EventLoop来为他服务
     - 自定义handler绑到channel上进行业务逻辑处理
   - EventLoop和channel:
     - EventLoop和一个线程绑定，在EventLoopGroup线程池中，会被当做一个线程来进行使用，其中包含有selector，可以进行轮询
     - Channel连接网络套接字或者能够进行I/O操作的组件，对端进行网络通信、注册和数据操作等功能，创建完毕后注册到轮询事件上去
     - 一般来说一个channel对应一个EventLoop

4. SpringCloud Eureka了解吗? 对比一下ZK eureka和 console? 用的时候有没有遇到什么坑, 怎么解决的?

   - SpringCloud Eureka
     - 一个服务发现框架，主要组件有Eureka-Client和Eureka-Server。
     - 服务中心是Eureka-Server，服务提供者通过client将服务注册到服务中心，服务消费者通过client获取注册服务信息，通过Feign等手段调用服务
     - 具有负载均衡和服务故障转移功能
   - ZK 和 Eureka对比
     - CAP理论 分布式系统不可能同时满足 C一致性 A可用性 P分区容错性
     - ZK关注 CP，可用性无法保证，有时候ZK中master节点挂掉，进行选举时时间过长，这时整个集群的服务都不可用，就导致无法满足可用性
     - Eureka关注AP，优先保证可用性，几个节点挂掉不影响其他节点正常工作，可以通过其他Eureka节点完成注册服务，但一致性不一定有保障；此外，他还有自我保护机制
   - 坑
     - 在多服务器k8s集群上，将Eureka部署到A节点，A节点的服务无法注册，而B节点的服务可以注册的问题。
     - 解决：在发现地址中原本填的是域名，后改为IP地址就可以注册上去了，暂时还没搞懂为什么
     - 怀疑是服务器上nginx代理的原因

5. SpringCloud里你还对哪些组件比较熟悉? 看过哪个的源码, 能简单介绍下他的原理吗?

   - 组件Feign
     - Feign是一个声明式WebService客户端，是一种http请求调用的轻量级框架，以Java注解的方式调用Http请求，是一个伪客户端，可以简化HTTP API开发
     - 让调用其他服务的接口像调用service一样简单
   - Feign及其源码
     - Feign 面向接口的动态代理方式生成实现类，根据接口注解，解析成内部表现MethodHandler
     - 基于RequestBean动态生成Request,使用Encoder将Bean转换成Http报文
     - 拦截器负责对请求和返回结果进行装饰
     - 还有日志记录和重试器
     - ReflectiveFeign ，Encode,Decoder，Retryer

6. RocketMQ你们用来做什么了? 看过源码吗? 能介绍一下他的消息存储机制吗?事务消息?顺序消息?

   - RocketMQ 在开发的DevOps平台中用来实现邮箱注册，RabbitMQ在在线放映室平台中用来实现手机验证码注册，这些功能的接口响应很慢, 会导致用户线程长时间等待最终断开，所有用MQ来实现异步
   - 暂时还没看源码。。。打算看
   - 消息存储机制：
     - 消息文件（commitLog），采用单一文件存储所有主题消息，保证完全的顺序写
     - 消息消费队列（consumeQueue），消息到达消息文件后，通过RequestMessageService线程转发给消息消费队列和索引文件
     - Hash索引文件、监测点文件和关闭异常文件
   - 事务消息
     - prepare消息：半消息，标志该消息处于“暂时不能投递”状态，不会被consumer消费，等到服务端收到生成者对该消息的commit和rollback后，才会被正常投递或回滚
     - 两阶段提交：
       - 1.生产者向服务器发送prepare消息，服务端确认后回调通知生产者执行本地事务
       - 2.生产者执行完本地事务，根据结果返回commit/rollback/unknown状态玛做出不同回应
     - 事务状态定时回查：服务端如果收不到状态码，回定时回调检查生产者本地事务执行状态，保证最终能和本地事务状态一致
   - 顺序消息
     - 通过MessageQueueSelector来实现，根据具体业务规则来规定消息的发送顺序，其内部原理是随机/Hash，获取路由信息后会选择相应的队列
     - 在消费者端使用MessageListenerOrderly进行顺序的消费

7. Redis用来做什么了? 有没有遇到缓存和数据库数据不一致的情况,怎么解决? Redis支持事务吗? Redis支持的数据结构知道/用过哪些? Redis为什么快? Redis为什么用跳表 而不用B+树?Redis持久化?

   - Redis用处：在分布式爬虫中用来充当共享数据缓存，对数据进行去重和统一，在一些查询操作中代替MySQL数据库返回结果，提高查询效率
   - 暂时没遇到过缓存和数据库不一致的情况，但了解到双写一致性问题和解决方案
   - 双写一致性问题
     - 先更新数据库，再更新缓存
       - 更新数据库的操作顺序到更新缓存时顺序不一定一致，会造成脏数据
       - 写请求很多，读请求很少，频繁更新缓存却没发挥缓存的效果
     - 先更新数据库，再删除缓存
       - 缓存删除失败时，其他用户读到的仍然是旧的缓存数据
     - 先删除缓存，再更新数据库
       - 删除缓存失败，但更新数据库成功，会造成脏数据
     - 都无法保证任何场景下数据库与缓存数据完全一致
   - 解决方案
     - 将数据库缓存更新和读取操作进行串行化
     - 项目里维护一组线程池和内存队列
     - 更新数据时，根据数据唯一标志将请求路由到一个jvm队列中，然后更新，请求结束
     - 读数据时，先查缓存，数据不存在，根据唯一标志路由，发送到同一jvm队列中，重新读取后更新缓存
     - 由于都在同一队列中，执行顺序具有先后性
   - 支持事务，可以叫做支持半事务
     - Redis的操作是原子性的，通过MULTI、EXEC、DISCARD和WATCH 四个原语实现事务
     - 但redis事务不支持回滚，它更像是一个脚本，将所有操作序列化，然后顺序执行
     - 某条操作出现错误结果，不会影响其他操作继续执行，会一致执行到底，可以认为Redis事务并不具有原子性
   - 数据结构
     - String :Set Get设置键值对
     - Hash ：存放结构化对象，可以用来做简单的session功能，设置过期时间并存储用户信息
     - List：列表，可做FIFO队列作用
     - Set：存放不重复值的集合，用于全局去重
     - sortedSet：带权重的Set结构，可以根据权重进行排序
   - Redis为什么快？
     - 纯内存操作
     - 单线程，避免频繁上下文切换带来性能瓶颈
     - 采用多路复用模型（允许单个线程里处理多个请求）
     - 数据结构简单，操作节省时间
   - 用跳表不用B+树
     - 由于Redis属于纯内存操作，跳表比B+树更节省内存
     - 更好地支持范围查询，跳表可以按序查找，B+树找到小值后，还需要中序遍历找范围内其他值，同时sortSet也具有顺序性
     - 跳表更加易于实现，调试简单
     - B+树插入删除可能引起树结构调整，而跳表只是按序遍历插入，不会引起复杂操作
   - Redis持久化
     - RDB持久化
       - 把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发
       - .RDB是二进制文件，恢复快，但无法实时持久化
     - AOF持久化
       - 以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的
       - 解决了实时持久化问题，但恢复慢，且文件大
     - 混合方式
       - 增量AOF日志和RDB快照

8. 为什么用Docker, 有没有遇到什么问题, Linux Docker的实现原理, Kubernetes自己在服务器上部署的吗? K8S中的POD SERVICE是什么, 部署过有状态服务吗, 部署有状态服务要注意什么? Istio是用来做什么的,只用K8S不行吗?

   - 为什么用Docker
     - Docker可以很方便的创建和管理镜像，以及管理已经生成的和正在运行的容器
     - 容器可以将应用程序打包，其中包含代码以及依赖库和配置文件，部署的时候十分方便，并且在微服务的结构下，各个应用之间也做到了隔离，互不影响
     - 解决了开发/测试/生产环境配置不同的问题
   - 遇到的问题
     - docker拉取镜像慢
   - 实现原理
     - 通过Linux的 Namespace运行相互隔离的Docker容器
     - 将Docker进程与用户进程隔离开来
     - 为每个容器创建独立IP，通过网络连接方式（网桥）对外提供服务
     - 将需要的目录挂载到容器上，同时也将其他目录隔离
     - CGroups进行物理资源的隔离
     - UnionFS是镜像的基础
   - k8s采用kube-admin部署
   - pod
     - K8S最小部署单元，不是一个程序/进程，是一个环境（包含容器，存储，网络IP端口，配置等），可以运行一个或多个container，临时性的，用完即丢弃的
   - service
     - pod临时性导致ip:port时刻变化，想要提供服务调用方无法感知，就引入了service，service暴露端口，绑定到pod，通过service可以访问pod提供的服务
   - 有状态服务
     - 需要数据存储功能的服务，多线程类型的服务
     - 如一些数据库持久化部署需要用到有状态服务
     - 需要注意数据的挂载PV，PVC等概念，要挂载到稳定的节点上
   - Istio
     - 是K8S的互补，主要关注服务发现，k8s只负责基本的调度和容器编排
     - Istio功能层次更高，可以管理服务，提供一些代理，故障排查，灰度发布等额外功能
     - 可以结合良好地前端让k8s管理可视化

9. gitflow?

   - gitHub进行开发和代码管理，具体流程遵循git flow流程
     - 编码前先从远程仓库pull最新版代码
     - 开发一个功能，就要新建一个分支（branch），在这个分支上编码，不要再master分支上编码，比如要开发一个房间模块，新建一个分支命名为 room
     - 编码结束后，commit提交检查
     - 检查无误后，将本地仓库push到远程仓库的分支上，比如当前为room
     - 当分支功能开发完毕并通过测试后，发起 pull Request请求，
     - review完毕，Merge到master分支上

10. 详细介绍一下权限管理模块? 数据权限管理怎么做的?

    - 权限管理
      - 采用RBAC模型，用 用户-角色-功能点  三层结构，对功能点和用户进行解耦，让用户拥有角色进而拥有功能点，达到赋予最小权限原则和职责分离原则
      - 用户关联角色，角色关联功能点，将这些关联关系抽象成表，以各自实体的主键代表，即使实体其他信息更新也不会影响关联关系
      - 在用户登录时就进行一次查询，将用户相关角色，组织信息添加至token，进行返回
      - 将数据ID和用户ID设置为联合索引实现索引覆盖，减少回表操作的耗时
      - 数据权限：把用户和该用户能查看的数据ID关联关系抽象成表，每当用户新增数据时，就往这张表中插入一条数据，代表用户可以访问这条数据，在查询时，需要通过查询该表来确定是否具有访问该条数据的权限
      - 使用：
        - 将“查询用户xx可以查看的所有数据ID”这个接口暴露，其他服务feign调用，返回一个列表，过滤掉没有权限查看的数据ID
      - 给同一团队的人赋予某个数据权限
        - 需要一张组织表，一张组织用户关联表，一张组织数据权限表
        - 如果用户有组织的话，调用“查询组织xx可以查看的所有数据ID”接口，返回一个列表，将这个列表作为查询用户权限时的限定范围

补充问题：

- 自己写一个starter
  - pom文件中引入 autoconfigure依赖和configuration-processor依赖
  - 配置文件读取类，从配置文件中为自动装配的类读取属性
  - 功能服务类，自动装配类会在classpath下找该类
  - 自动装配类，会注册成一个Bean，当不存在功能服务类的实例时会加载该方法生成实例
- Netty哪些地方设计比较好, 区分阻塞/非阻塞/异步/同步
  - 基于NIO，非阻塞的IO，即使当前线程没有响应，也不会被挂起，而是立刻返回，并发性能有很大的提高
  - 提供的channel组件，保证了异步的网络IO操作，虽然底层的NIO是同步的，但Netty用线程池保障了异步性，达成了事件驱动的异步模型
- ZK的选举过程/ Eureka的保护机制
  - ZK选举过程
    - 每个server发出一个投票，每次投票信息包含推举服务器的myid（服务器编号）和ZXID（数据ID，越大表示数据越新），由于是初始情况，都推举自己作为leader，此时都为LOOKING状态
    - 接收来自各个服务器的投票，判断投票是否有效
    - 处理投票，优先检查zxid，如果zxid相同，再检查myid
    - 统计投票信息，选出leader
    - 改变状态，follower状态变为FOLLOWING，leader变为LEADING
    - 这个过程优先保障了各个服务器之间数据的一致性，很适合CP原理，但有时候选举过程较长，造成服务不可用时间较长
  - Eureka保护机制
    - Eureka Server 运行期间会统计心跳失败比例在15分钟内是否低于85%
      - 低于85%，将这些实例保护起来，让它们不会过期
      - 防止网络情况波动时，造成服务不可用，但实际上这个服务是依然存活的
      - 但如果保护期间服务如果真的挂掉了，客户端就会拿到一个无效服务实例，所以客户端要有容错机制
- 应该先简单介绍一下双写一致性问题. 补充问题:还有没有其他更好的解决方案
  - 双写一致性在问题7中回答
  - 其他解决方案
    - 设置缓存有效时间
